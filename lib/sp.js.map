{"version":3,"sources":["../src/sp.js"],"names":[],"mappings":"AAAA;;;;;;;;AAOA,IAAM,QAAQ,QAAQ,MAAR,CAAR;;;;;;;;;AASN,IAAI,iBAAiB,SAAjB,cAAiB,CAAU,GAAV,EAAe,QAAf,EAAyB,EAAzB,EAA6B;;;AAG9C,QAAI,OAAO,QAAP,KAAqB,UAArB,EAAiC;AACjC,cAAM,IAAI,KAAJ,CAAU,iCAAV,CAAN,CADiC;KAArC;;;AAH8C,QAQ1C,CAAC,MAAM,OAAN,CAAc,GAAd,CAAD,EAAqB;AACrB,eAAO,SAAS,IAAI,KAAJ,CAAU,0BAAV,CAAT,CAAP,CADqB;KAAzB;;;AAR8C,QAa1C,IAAI,MAAJ,KAAe,CAAf,EAAkB;AAClB,eAAO,SAAS,IAAT,EAAe,EAAf,CAAP,CADkB;KAAtB;;;AAb8C,SAkB1C,IAAI,IAAI,CAAJ,EAAO,IAAI,IAAI,MAAJ,EAAY,GAA/B,EAAmC;AAC/B,YAAG,CAAC,MAAM,OAAN,CAAc,IAAI,CAAJ,CAAd,CAAD,IAA2B,OAAO,IAAI,CAAJ,CAAP,KAAmB,UAAnB,EAA+B;AACzD,mBAAO,SAAS,IAAI,KAAJ,CAAU,+EAA+E,CAA/E,GAAmF,aAAnF,CAAnB,CAAP,CADyD;SAA7D;KADJ;;AAMA,iBAAa,UAAC,GAAD,EAAM,QAAN,EAAmB;AAC5B,YAAI,UAAU,EAAV;YACA,QAAQ,IAAI,MAAJ,CAFgB;;AAI5B,YAAI,OAAO,SAAP,IAAO,GAAM;AACb,gBAAI,KAAK,IAAI,KAAJ,EAAL,CADS;AAEb,gBAAI,CAAC,EAAD,EAAK;AACL,uBADK;aAAT;;AAIA,gBAAI,KAAK,SAAL,EAAK,CAAC,GAAD,EAAM,GAAN,EAAc;AACnB,oBAAI,CAAC,GAAD,EAAM;AACN,4BAAQ,IAAR,CAAa,GAAb,EADM;AAEN,wBAAI,QAAQ,MAAR,KAAmB,KAAnB,EAA0B;AAC1B,+BAAO,SAAS,IAAT,EAAe,OAAf,CAAP,CAD0B;qBAA9B;AAGA,wBAAG,EAAH,EAAM;;AAEF,qCAAa,IAAb,EAFE;qBAAN;iBALJ,MASO;AACH,2BAAO,SAAS,GAAT,CAAP,CADG;iBATP;aADK,CANI;AAoBb,gBAAG,MAAM,OAAN,CAAc,EAAd,CAAH,EAAqB;AACjB,oBAAI,IAAI,GAAG,CAAH,CAAJ;oBACA,MAAM,GAAG,CAAH,CAAN;oBACA,OAAO,GAAG,KAAH,CAAS,CAAT,CAAP,CAHa;;AAKjB,qBAAK,IAAL,CAAU,EAAV,EALiB;AAMjB,kBAAE,KAAF,CAAQ,GAAR,EAAa,IAAb,EANiB;aAArB,MAOK;AACD,mBAAG,EAAH,EADC;aAPL;AAUA,gBAAG,CAAC,EAAD,EAAI;;AAEH,6BAAa,IAAb,EAFG;aAAP;SA9BO,CAJiB;;AAwC5B,eAxC4B;KAAnB,EA0CV,GA1CH,EA0CQ,QA1CR,EAxB8C;CAA7B;;AAsErB,OAAO,OAAP,GAAiB;AACb,YAAQ,gBAAS,GAAT,EAAc,QAAd,EAAuB;AAC3B,uBAAe,GAAf,EAAoB,QAApB,EAA8B,IAA9B,EAD2B;KAAvB;AAGR,cAAU,kBAAS,GAAT,EAAc,QAAd,EAAuB;AAC7B,uBAAe,GAAf,EAAoB,QAApB,EAA8B,KAA9B,EAD6B;KAAvB;CAJd","file":"sp.js","sourcesContent":["\"use strict\";\n/**\n * simple-series-parallel\n * A minimalist utility module for running async functions in series or parallel\n * Copyright(c) 2016 Jayesh Wadhwani\n * MIT Licensed\n */\nconst utils = require('util');\n\n/*\nfns is an array where each element can be:\n1. a function and/or\n2. an array with the following format: [function, context, arg0, arg1,...arg n]\nsp - true for series, false for parallel\n */\n\nvar seriesParallel = function (fns, callback, sp) {\n\n    //validation - callback needs to be a callable function\n    if (typeof(callback) !== \"function\") {\n        throw new Error('\"callback\" should be a function');\n    }\n\n    //should be an array\n    if (!utils.isArray(fns)) {\n        return callback(new Error('\"fns\" should be an array'));\n    }\n\n    //no functions just return an empty array\n    if (fns.length === 0) {\n        return callback(null, []);\n    }\n\n    //minor validation\n    for(let i = 0; i < fns.length; i++){\n        if(!utils.isArray(fns[i]) && (typeof(fns[i]) !== \"function\")){\n            return callback(new Error('An element should be either a function or an array. The element at index: ' + i + ' is neither'));\n        }\n    }\n\n    setImmediate((fns, callback) => {\n        let results = [],\n            count = fns.length;\n\n        var next = () => {\n            let fn = fns.shift();\n            if (!fn) {\n                return;\n            }\n\n            var cb = (err, res) => {\n                if (!err) {\n                    results.push(res);\n                    if (results.length === count) {\n                        return callback(null, results);\n                    }\n                    if(sp){\n                        //next();\n                        setImmediate(next);\n                   }\n                } else {\n                    return callback(err);\n                }\n            };\n            if(utils.isArray(fn)){\n                let f = fn[0],\n                    ctx = fn[1],\n                    args = fn.slice(2);\n\n                args.push(cb);\n                f.apply(ctx, args);\n            }else{\n                fn(cb);\n            }\n            if(!sp){\n                //next();\n                setImmediate(next);\n            }\n        };\n\n        next();\n\n    }, fns, callback);\n};\n\n\nmodule.exports = {\n    series: function(fns, callback){\n        seriesParallel(fns, callback, true);\n    },\n    parallel: function(fns, callback){\n        seriesParallel(fns, callback, false);\n    }\n};\n"]}